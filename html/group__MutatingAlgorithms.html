<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Mutating Algorithms</title>
    <link href="../style/default.css" rel="stylesheet" type="text/css" />
    <link href="../style/ustlstyle.css" rel="stylesheet" type="text/css" />
    <meta http-equiv="Content-Type" content="text/xhtml+xml; charset=ISO-8859-1" />
    <meta name="Description" content="API and usage description for uSTL, a size-optimized STL implementation" />
    <meta name="Keywords" content="C++, STL, template, bloat, optimization" />
</head>
<body>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mutating Algorithms<div class="ingroups"><a class="el" href="group__Algorithms.html">Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__GeneratorAlgorithms"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeneratorAlgorithms.html">Generator Algorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__HeapAlgorithms"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HeapAlgorithms.html">Heap Algorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__NumericAlgorithms"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html">Numeric Algorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__RawStorageAlgorithms"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html">Raw Storage Algorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__SetAlgorithms"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SetAlgorithms.html">Set Algorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__SortingAlgorithms"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html">Sorting Algorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__SwapAlgorithms"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SwapAlgorithms.html">Swap Algorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga27eddf28c0d25e6a6b402688a244e65e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ga27eddf28c0d25e6a6b402688a244e65e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga27eddf28c0d25e6a6b402688a244e65e">ustl::replace</a> (ForwardIterator first, ForwardIterator last, const T &amp;old_value, const T &amp;new_value)</td></tr>
<tr class="separator:ga27eddf28c0d25e6a6b402688a244e65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2617c97fe6ce25d4601d2f80348fb9c3"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga2617c97fe6ce25d4601d2f80348fb9c3"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga2617c97fe6ce25d4601d2f80348fb9c3">ustl::replace_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;old_value, const T &amp;new_value)</td></tr>
<tr class="separator:ga2617c97fe6ce25d4601d2f80348fb9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03630073b49d4b886193dadc5ac5e6c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga03630073b49d4b886193dadc5ac5e6c9"></a>
template&lt;typename BidirectionalIterator &gt; </td></tr>
<tr class="memitem:ga03630073b49d4b886193dadc5ac5e6c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga03630073b49d4b886193dadc5ac5e6c9">ustl::reverse</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="memdesc:ga03630073b49d4b886193dadc5ac5e6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse reverses a range. That is: for every i such that 0 &lt;= i &lt;= (last - first) / 2), it exchanges *(first + i) and *(last - (i + 1)). <br/></td></tr>
<tr class="separator:ga03630073b49d4b886193dadc5ac5e6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257779dd8e2656a31e40faf422ec70ac"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga257779dd8e2656a31e40faf422ec70ac"></a>
template&lt;typename BidirectionalIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga257779dd8e2656a31e40faf422ec70ac"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga257779dd8e2656a31e40faf422ec70ac">ustl::reverse_copy</a> (BidirectionalIterator first, BidirectionalIterator last, OutputIterator result)</td></tr>
<tr class="memdesc:ga257779dd8e2656a31e40faf422ec70ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses [first,last) and writes it to <code>output</code>. <br/></td></tr>
<tr class="separator:ga257779dd8e2656a31e40faf422ec70ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa28c0eb7cbd2b0665c5974e6d80e361f"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa28c0eb7cbd2b0665c5974e6d80e361f"></a>
template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gaa28c0eb7cbd2b0665c5974e6d80e361f"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaa28c0eb7cbd2b0665c5974e6d80e361f">ustl::rotate</a> (ForwardIterator first, ForwardIterator middle, ForwardIterator last)</td></tr>
<tr class="memdesc:gaa28c0eb7cbd2b0665c5974e6d80e361f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges ranges [first, middle) and [middle, last) <br/></td></tr>
<tr class="separator:gaa28c0eb7cbd2b0665c5974e6d80e361f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga302b1a754f1eccb3434441d410f93866"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga302b1a754f1eccb3434441d410f93866"></a>
template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga302b1a754f1eccb3434441d410f93866"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga302b1a754f1eccb3434441d410f93866">ustl::rotate_copy</a> (ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result)</td></tr>
<tr class="memdesc:ga302b1a754f1eccb3434441d410f93866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges ranges [first, middle) and [middle, last) into <code>result</code>. <br/></td></tr>
<tr class="separator:ga302b1a754f1eccb3434441d410f93866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60a4dc1406ae30880b3d0629ee46851e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga60a4dc1406ae30880b3d0629ee46851e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga60a4dc1406ae30880b3d0629ee46851e">ustl::remove_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;value)</td></tr>
<tr class="separator:ga60a4dc1406ae30880b3d0629ee46851e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4536237c29c04bd692110d5198099e75"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename RInputIterator &gt; </td></tr>
<tr class="memitem:ga4536237c29c04bd692110d5198099e75"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga4536237c29c04bd692110d5198099e75">ustl::remove_copy</a> (InputIterator first, InputIterator last, OutputIterator result, RInputIterator rfirst, RInputIterator rlast)</td></tr>
<tr class="separator:ga4536237c29c04bd692110d5198099e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cea777ba522e97ab163e8e3bd6390af"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ga6cea777ba522e97ab163e8e3bd6390af"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga6cea777ba522e97ab163e8e3bd6390af">ustl::remove</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr class="separator:ga6cea777ba522e97ab163e8e3bd6390af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae843d0bdce4ccf55205edb33eb3ba0d0"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gae843d0bdce4ccf55205edb33eb3ba0d0"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gae843d0bdce4ccf55205edb33eb3ba0d0">ustl::unique_copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:gae843d0bdce4ccf55205edb33eb3ba0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga692dd0a978c4f31bacc653defaead8f3"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga692dd0a978c4f31bacc653defaead8f3"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga692dd0a978c4f31bacc653defaead8f3">ustl::unique</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:ga692dd0a978c4f31bacc653defaead8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd931061ff91b8bc27954db50d09843"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gaffd931061ff91b8bc27954db50d09843"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaffd931061ff91b8bc27954db50d09843">ustl::copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:gaffd931061ff91b8bc27954db50d09843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012b47e2efb4ab384d9c3b47fbb70365"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga012b47e2efb4ab384d9c3b47fbb70365"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga012b47e2efb4ab384d9c3b47fbb70365">ustl::copy_n</a> (InputIterator first, size_t count, OutputIterator result)</td></tr>
<tr class="separator:ga012b47e2efb4ab384d9c3b47fbb70365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6e90e73c912bb2d85e2f44da00188b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7c6e90e73c912bb2d85e2f44da00188b"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga7c6e90e73c912bb2d85e2f44da00188b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga7c6e90e73c912bb2d85e2f44da00188b">ustl::copy_backward</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="memdesc:ga7c6e90e73c912bb2d85e2f44da00188b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy copies elements from the range (last, first] to result.Copies elements starting at last, decrementing both last and result. <br/></td></tr>
<tr class="separator:ga7c6e90e73c912bb2d85e2f44da00188b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad486998e69ac22172965db1c8b893e9a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:gad486998e69ac22172965db1c8b893e9a"><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gad486998e69ac22172965db1c8b893e9a">ustl::for_each</a> (InputIterator first, InputIterator last, UnaryFunction f)</td></tr>
<tr class="separator:gad486998e69ac22172965db1c8b893e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420b212976e71f04f4c32326194e948e"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga420b212976e71f04f4c32326194e948e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga420b212976e71f04f4c32326194e948e">ustl::copy</a> (const Container &amp;ctr, OutputIterator result)</td></tr>
<tr class="separator:ga420b212976e71f04f4c32326194e948e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64c71b8c66dcc68c43b373c7b9b2393"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:gaa64c71b8c66dcc68c43b373c7b9b2393"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaa64c71b8c66dcc68c43b373c7b9b2393">ustl::copy_if</a> (Container &amp;ctr, OutputIterator result, Predicate pred)</td></tr>
<tr class="separator:gaa64c71b8c66dcc68c43b373c7b9b2393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7336da576007f507195e75b65906265"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:gae7336da576007f507195e75b65906265"><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gae7336da576007f507195e75b65906265">ustl::for_each</a> (Container &amp;ctr, UnaryFunction f)</td></tr>
<tr class="separator:gae7336da576007f507195e75b65906265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bfbc6e6f1999aef61d107489d5b437b"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:ga8bfbc6e6f1999aef61d107489d5b437b"><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga8bfbc6e6f1999aef61d107489d5b437b">ustl::for_each</a> (const Container &amp;ctr, UnaryFunction f)</td></tr>
<tr class="separator:ga8bfbc6e6f1999aef61d107489d5b437b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c67dd2fddca5eec86a948bfb52be4ff"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:ga0c67dd2fddca5eec86a948bfb52be4ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga0c67dd2fddca5eec86a948bfb52be4ff">ustl::transform</a> (Container &amp;ctr, UnaryFunction op)</td></tr>
<tr class="separator:ga0c67dd2fddca5eec86a948bfb52be4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga595997b23ca65b0e63f01794c5db99a5"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:ga595997b23ca65b0e63f01794c5db99a5"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga595997b23ca65b0e63f01794c5db99a5">ustl::transform</a> (Container &amp;ctr, OutputIterator result, UnaryFunction op)</td></tr>
<tr class="separator:ga595997b23ca65b0e63f01794c5db99a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2102561c0d380e16e1effabeba58754"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename InputIterator , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:gae2102561c0d380e16e1effabeba58754"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gae2102561c0d380e16e1effabeba58754">ustl::transform</a> (Container &amp;ctr, InputIterator first, OutputIterator result, BinaryFunction op)</td></tr>
<tr class="separator:gae2102561c0d380e16e1effabeba58754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a666ae8eb20398682c574b8efb595ea"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:ga8a666ae8eb20398682c574b8efb595ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga8a666ae8eb20398682c574b8efb595ea">ustl::replace</a> (Container &amp;ctr, const T &amp;old_value, const T &amp;new_value)</td></tr>
<tr class="separator:ga8a666ae8eb20398682c574b8efb595ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88aa14b0e4f6d2a41c8cb84cb6bf7d09"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Predicate , typename T &gt; </td></tr>
<tr class="memitem:ga88aa14b0e4f6d2a41c8cb84cb6bf7d09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga88aa14b0e4f6d2a41c8cb84cb6bf7d09">ustl::replace_if</a> (Container &amp;ctr, Predicate pred, const T &amp;new_value)</td></tr>
<tr class="separator:ga88aa14b0e4f6d2a41c8cb84cb6bf7d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06a187fb030b8f86fe5f0bb35f1433f"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:gaf06a187fb030b8f86fe5f0bb35f1433f"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaf06a187fb030b8f86fe5f0bb35f1433f">ustl::replace_copy</a> (const Container &amp;ctr, OutputIterator result, const T &amp;old_value, const T &amp;new_value)</td></tr>
<tr class="separator:gaf06a187fb030b8f86fe5f0bb35f1433f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4600f1b212331c8ce198fb1af1de15"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename Predicate , typename T &gt; </td></tr>
<tr class="memitem:ga6d4600f1b212331c8ce198fb1af1de15"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga6d4600f1b212331c8ce198fb1af1de15">ustl::replace_copy_if</a> (const Container &amp;ctr, OutputIterator result, Predicate pred, const T &amp;new_value)</td></tr>
<tr class="separator:ga6d4600f1b212331c8ce198fb1af1de15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189fa3d39078139d039cea754c490310"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga189fa3d39078139d039cea754c490310"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga189fa3d39078139d039cea754c490310">ustl::remove_copy</a> (const Container &amp;ctr, OutputIterator result, const T &amp;value)</td></tr>
<tr class="separator:ga189fa3d39078139d039cea754c490310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae020c456b0dcdb049c37b08bc9b87ee3"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:gae020c456b0dcdb049c37b08bc9b87ee3"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gae020c456b0dcdb049c37b08bc9b87ee3">ustl::remove_copy_if</a> (const Container &amp;ctr, OutputIterator result, Predicate pred)</td></tr>
<tr class="separator:gae020c456b0dcdb049c37b08bc9b87ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc16bfb34449db8062d3d1a212713efa"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:gabc16bfb34449db8062d3d1a212713efa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gabc16bfb34449db8062d3d1a212713efa">ustl::remove</a> (Container &amp;ctr, const T &amp;value)</td></tr>
<tr class="separator:gabc16bfb34449db8062d3d1a212713efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a5a9488053677405afa744edf815b77"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga0a5a9488053677405afa744edf815b77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga0a5a9488053677405afa744edf815b77">ustl::remove</a> (Container &amp;ctr, ForwardIterator rfirst, ForwardIterator rlast)</td></tr>
<tr class="separator:ga0a5a9488053677405afa744edf815b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b3430a2ea014523e9f54b538b7fecf"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Predicate &gt; </td></tr>
<tr class="memitem:gab9b3430a2ea014523e9f54b538b7fecf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gab9b3430a2ea014523e9f54b538b7fecf">ustl::remove_if</a> (Container &amp;ctr, Predicate pred)</td></tr>
<tr class="separator:gab9b3430a2ea014523e9f54b538b7fecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013e60a5eb03c93781f9ade1c724beec"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga013e60a5eb03c93781f9ade1c724beec"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga013e60a5eb03c93781f9ade1c724beec">ustl::unique_copy</a> (const Container &amp;ctr, OutputIterator result)</td></tr>
<tr class="separator:ga013e60a5eb03c93781f9ade1c724beec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18dd0f3a49cf57f7b06b77df5a379e0"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:gad18dd0f3a49cf57f7b06b77df5a379e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gad18dd0f3a49cf57f7b06b77df5a379e0">ustl::unique</a> (Container &amp;ctr)</td></tr>
<tr class="separator:gad18dd0f3a49cf57f7b06b77df5a379e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga040d93fb7659f4a30075759df2db827e"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga040d93fb7659f4a30075759df2db827e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga040d93fb7659f4a30075759df2db827e">ustl::unique</a> (Container &amp;ctr, BinaryPredicate binary_pred)</td></tr>
<tr class="separator:ga040d93fb7659f4a30075759df2db827e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86967546e25f8091fa08595de9afe9d4"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga86967546e25f8091fa08595de9afe9d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga86967546e25f8091fa08595de9afe9d4">ustl::reverse</a> (Container &amp;ctr)</td></tr>
<tr class="separator:ga86967546e25f8091fa08595de9afe9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06e3b30adb83643e79e738ed7477e45"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:gaf06e3b30adb83643e79e738ed7477e45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaf06e3b30adb83643e79e738ed7477e45">ustl::rotate</a> (Container &amp;ctr, off_t offset)</td></tr>
<tr class="separator:gaf06e3b30adb83643e79e738ed7477e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedfffcaeab46ff4ae8ba5f1404d87aa8"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaedfffcaeab46ff4ae8ba5f1404d87aa8"></a>
template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:gaedfffcaeab46ff4ae8ba5f1404d87aa8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaedfffcaeab46ff4ae8ba5f1404d87aa8">ustl::push_heap</a> (RandomAccessIterator first, RandomAccessIterator last, Compare comp)</td></tr>
<tr class="memdesc:gaedfffcaeab46ff4ae8ba5f1404d87aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the *&ndash;last into the preceeding range assumed to be a heap. <br/></td></tr>
<tr class="separator:gaedfffcaeab46ff4ae8ba5f1404d87aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e2b7f2099a917f04bd58283d4c8ed34"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ga9e2b7f2099a917f04bd58283d4c8ed34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga9e2b7f2099a917f04bd58283d4c8ed34">ustl::pop_heap</a> (RandomAccessIterator first, RandomAccessIterator last, Compare comp)</td></tr>
<tr class="separator:ga9e2b7f2099a917f04bd58283d4c8ed34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Algorithms for modifying your data in some way. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga420b212976e71f04f4c32326194e948e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::copy </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy copies elements from the range [first, last) to the range [result, result + (last - first)). That is, it performs the assignments *result = *first, *(result + 1) = *(first + 1), and so on. [1] Generally, for every integer n from 0 to last - first, copy performs the assignment *(result + n) = *(first + n). Assignments are performed in forward order, i.e. in order of increasing n. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gaffd931061ff91b8bc27954db50d09843">ustl::copy()</a>.</p>

</div>
</div>
<a class="anchor" id="gaffd931061ff91b8bc27954db50d09843"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy copies elements from the range [first, last) to the range [result, result + (last - first)). That is, it performs the assignments *result = *first, *(result + 1) = *(first + 1), and so on. [1] Generally, for every integer n from 0 to last - first, copy performs the assignment *(result + n) = *(first + n). Assignments are performed in forward order, i.e. in order of increasing n. </p>

<p>Referenced by <a class="el" href="classustl_1_1vector.html#a716c26d58d5de2adeed9a06a0e459ca3">ustl::vector&lt; T &gt;::assign()</a>, <a class="el" href="group__MutatingAlgorithms.html#ga420b212976e71f04f4c32326194e948e">ustl::copy()</a>, <a class="el" href="classustl_1_1istringstream.html#a6bb89580fea0fc3b86dfea030ccbfeec">ustl::istringstream::getline()</a>, <a class="el" href="group__SortingAlgorithms.html#ga7fb61aeaee59d94c82c6e8e234dbabf6">ustl::merge()</a>, <a class="el" href="group__MutatingAlgorithms.html#ga302b1a754f1eccb3434441d410f93866">ustl::rotate_copy()</a>, <a class="el" href="group__PredicateAlgorithms.html#gaf12f1c23baeff1f70ff80f1cd436c6c9">ustl::set_difference()</a>, <a class="el" href="group__PredicateAlgorithms.html#ga71951a9e5ab78fe83d062b3309b5e7be">ustl::set_symmetric_difference()</a>, and <a class="el" href="group__PredicateAlgorithms.html#ga18fe33a30effaf461623c701a8770b51">ustl::set_union()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa64c71b8c66dcc68c43b373c7b9b2393"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename OutputIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::copy_if </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy_if copies elements from the range [first, last) to the range [result, result + (last - first)) if pred(*i) returns true. </p>

</div>
</div>
<a class="anchor" id="ga012b47e2efb4ab384d9c3b47fbb70365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::copy_n </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy_n copies elements from the range [first, first + n) to the range [result, result + n). That is, it performs the assignments *result = *first, *(result + 1) = *(first + 1), and so on. Generally, for every integer i from 0 up to (but not including) n, copy_n performs the assignment *(result + i) = *(first + i). Assignments are performed in forward order, i.e. in order of increasing n. </p>

<p>References <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">ustl::count()</a>.</p>

<p>Referenced by <a class="el" href="classustl_1_1string.html#a7f7ff373d3cba9e6d20b5295a7c50deb">ustl::string::append()</a>, <a class="el" href="classustl_1_1memblock.html#a3f632cfd6d9096994b27d5fff9c261f3">ustl::memblock::assign()</a>, <a class="el" href="classustl_1_1string.html#ae75dc8b6cc0c790327348f5ce9612794">ustl::string::assign()</a>, <a class="el" href="classustl_1_1string.html#acc6cbf1ad9fc0ec57a33a00d3f7e104c">ustl::string::copy()</a>, <a class="el" href="classustl_1_1memlink.html#a5052fa1c942cbc7da92408dcfc021dac">ustl::memlink::fill()</a>, <a class="el" href="namespaceustl.html#a07c267e68ef570e9749ffed0ee581ef7">ustl::indexv_to_iteratorv()</a>, <a class="el" href="classustl_1_1memblock.html#a15a9c534155b48de96d44330f6f98ca3">ustl::memblock::reserve()</a>, and <a class="el" href="classustl_1_1string.html#ab241236334abac837c2c7b9291dcb119">ustl::string::string()</a>.</p>

</div>
</div>
<a class="anchor" id="gae7336da576007f507195e75b65906265"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnaryFunction ustl::for_each </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For_each applies the function object f to each element in the range [first, last); f's return value, if any, is ignored. Applications are performed in forward order, i.e. from first to last. For_each returns the function object after it has been applied to each element. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gad486998e69ac22172965db1c8b893e9a">ustl::for_each()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8bfbc6e6f1999aef61d107489d5b437b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnaryFunction ustl::for_each </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For_each applies the function object f to each element in the range [first, last); f's return value, if any, is ignored. Applications are performed in forward order, i.e. from first to last. For_each returns the function object after it has been applied to each element. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gad486998e69ac22172965db1c8b893e9a">ustl::for_each()</a>.</p>

</div>
</div>
<a class="anchor" id="gad486998e69ac22172965db1c8b893e9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnaryFunction ustl::for_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For_each applies the function object f to each element in the range [first, last); f's return value, if any, is ignored. Applications are performed in forward order, i.e. from first to last. For_each returns the function object after it has been applied to each element. </p>

<p>Referenced by <a class="el" href="group__MutatingAlgorithms.html#gae7336da576007f507195e75b65906265">ustl::for_each()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e2b7f2099a917f04bd58283d4c8ed34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ustl::pop_heap </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the largest element from the heap (*first) and places it at *(last-1) [first, last-1) is a heap after this operation. </p>

<p>References <a class="el" href="group__SwapAlgorithms.html#ga70beeb79393e6c3f5c86237f501a583b">ustl::iter_swap()</a>, and <a class="el" href="group__SortingAlgorithms.html#ga94c0e9d3d9c2f737c7a8d47b9608b351">ustl::make_heap()</a>.</p>

<p>Referenced by <a class="el" href="group__SortingAlgorithms.html#gab358f9493a0e80f2dc6fdf14f6dce111">ustl::sort_heap()</a>.</p>

</div>
</div>
<a class="anchor" id="gabc16bfb34449db8062d3d1a212713efa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::remove </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove removes from the range [first, last) all elements that are equal to value. That is, remove returns an iterator new_last such that the range [first, new_last) contains no elements equal to value. Remove is stable, meaning that the relative order of elements that are not equal to value is unchanged. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#ga60a4dc1406ae30880b3d0629ee46851e">ustl::remove_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a5a9488053677405afa744edf815b77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::remove </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>rfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>rlast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove removes from the range [first, last) all elements that have an iterator in range [rfirst, rlast). The range is assumed to be sorted. That is, remove returns an iterator new_last such that the range [first, new_last) contains no elements whose iterators are in [rfirst, rlast). Remove is stable, meaning that the relative order of elements that are not equal to value is unchanged. This version of the algorithm is a uSTL extension. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#ga60a4dc1406ae30880b3d0629ee46851e">ustl::remove_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6cea777ba522e97ab163e8e3bd6390af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator ustl::remove </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove removes from the range [first, last) all elements that are equal to value. That is, remove returns an iterator new_last such that the range [first, new_last) contains no elements equal to value. [1] The iterators in the range [new_last, last) are all still dereferenceable, but the elements that they point to are unspecified. Remove is stable, meaning that the relative order of elements that are not equal to value is unchanged. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#ga60a4dc1406ae30880b3d0629ee46851e">ustl::remove_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga189fa3d39078139d039cea754c490310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename OutputIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::remove_copy </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove_copy copies elements that are not equal to value from the range [first, last) to a range beginning at result. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as in the range [first, last). </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#ga60a4dc1406ae30880b3d0629ee46851e">ustl::remove_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga60a4dc1406ae30880b3d0629ee46851e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::remove_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove_copy copies elements that are not equal to value from the range [first, last) to a range beginning at result. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as in the range [first, last). </p>

<p>Referenced by <a class="el" href="group__MutatingAlgorithms.html#ga6cea777ba522e97ab163e8e3bd6390af">ustl::remove()</a>, and <a class="el" href="group__MutatingAlgorithms.html#ga189fa3d39078139d039cea754c490310">ustl::remove_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4536237c29c04bd692110d5198099e75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename RInputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::remove_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RInputIterator&#160;</td>
          <td class="paramname"><em>rfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RInputIterator&#160;</td>
          <td class="paramname"><em>rlast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove_copy copies elements pointed to by iterators in [rfirst, rlast) from the range [first, last) to a range beginning at result. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as in the range [first, last). Range [rfirst, rlast) is assumed to be sorted. This algorithm is a uSTL extension. </p>

</div>
</div>
<a class="anchor" id="gae020c456b0dcdb049c37b08bc9b87ee3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename OutputIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove_copy_if copies elements from the range [first, last) to a range beginning at result, except that elements for which pred is true are not copied. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as in the range [first, last). </p>

<p>Referenced by <a class="el" href="group__MutatingAlgorithms.html#gab9b3430a2ea014523e9f54b538b7fecf">ustl::remove_if()</a>.</p>

</div>
</div>
<a class="anchor" id="gab9b3430a2ea014523e9f54b538b7fecf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::remove_if </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove_if removes from the range [first, last) every element x such that pred(x) is true. That is, remove_if returns an iterator new_last such that the range [first, new_last) contains no elements for which pred is true. The iterators in the range [new_last, last) are all still dereferenceable, but the elements that they point to are unspecified. Remove_if is stable, meaning that the relative order of elements that are not removed is unchanged. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gae020c456b0dcdb049c37b08bc9b87ee3">ustl::remove_copy_if()</a>.</p>

</div>
</div>
<a class="anchor" id="ga27eddf28c0d25e6a6b402688a244e65e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::replace </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace replaces every element in the range [first, last) equal to old_value with new_value. That is: for every iterator i, if *i == old_value then it performs the assignment *i = new_value. </p>

<p>Referenced by <a class="el" href="group__MutatingAlgorithms.html#ga8a666ae8eb20398682c574b8efb595ea">ustl::replace()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8a666ae8eb20398682c574b8efb595ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::replace </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace replaces every element in the range [first, last) equal to old_value with new_value. That is: for every iterator i, if *i == old_value then it performs the assignment *i = new_value. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#ga27eddf28c0d25e6a6b402688a244e65e">ustl::replace()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2617c97fe6ce25d4601d2f80348fb9c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::replace_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace_copy copies elements from the range [first, last) to the range [result, result + (last-first)), except that any element equal to old_value is not copied; new_value is copied instead. More precisely, for every integer n such that 0 &lt;= n &lt; last-first, replace_copy performs the assignment *(result+n) = new_value if *(first+n) == old_value, and *(result+n) = *(first+n) otherwise. </p>

<p>Referenced by <a class="el" href="group__MutatingAlgorithms.html#gaf06a187fb030b8f86fe5f0bb35f1433f">ustl::replace_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf06a187fb030b8f86fe5f0bb35f1433f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename OutputIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::replace_copy </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace_copy copies elements from the range [first, last) to the range [result, result + (last-first)), except that any element equal to old_value is not copied; new_value is copied instead. More precisely, for every integer n such that 0 &lt;= n &lt; last-first, replace_copy performs the assignment *(result+n) = new_value if *(first+n) == old_value, and *(result+n) = *(first+n) otherwise. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#ga2617c97fe6ce25d4601d2f80348fb9c3">ustl::replace_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d4600f1b212331c8ce198fb1af1de15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename OutputIterator , typename Predicate , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::replace_copy_if </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace_copy_if copies elements from the range [first, last) to the range [result, result + (last-first)), except that any element for which pred is true is not copied; new_value is copied instead. More precisely, for every integer n such that 0 &lt;= n &lt; last-first, replace_copy_if performs the assignment *(result+n) = new_value if pred(*(first+n)), and *(result+n) = *(first+n) otherwise. </p>

</div>
</div>
<a class="anchor" id="ga88aa14b0e4f6d2a41c8cb84cb6bf7d09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Predicate , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::replace_if </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace_if replaces every element in the range [first, last) for which pred returns true with new_value. That is: for every iterator i, if pred(*i) is true then it performs the assignment *i = new_value. </p>

</div>
</div>
<a class="anchor" id="ga86967546e25f8091fa08595de9afe9d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::reverse </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reverse reverses a range. That is: for every i such that 0 &lt;= i &lt;= (last - first) / 2), it exchanges *(first + i) and *(last - (i + 1)). </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#ga03630073b49d4b886193dadc5ac5e6c9">ustl::reverse()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf06e3b30adb83643e79e738ed7477e45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::rotate </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exchanges ranges [first, middle) and [middle, last) </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gaa28c0eb7cbd2b0665c5974e6d80e361f">ustl::rotate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c67dd2fddca5eec86a948bfb52be4ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::transform </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The first version of transform performs the operation op(*i) for each iterator i in the range [first, last), and assigns the result of that operation to *o, where o is the corresponding output iterator. That is, for each n such that 0 &lt;= n &lt; last - first, it performs the assignment *(result + n) = op(*(first + n)). The return value is result + (last - first). </p>

<p>References <a class="el" href="group__PredicateAlgorithms.html#ga6a4516cd4b2891c8267d0a02a99d6661">ustl::transform()</a>.</p>

</div>
</div>
<a class="anchor" id="ga595997b23ca65b0e63f01794c5db99a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename OutputIterator , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::transform </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The first version of transform performs the operation op(*i) for each iterator i in the range [first, last), and assigns the result of that operation to *o, where o is the corresponding output iterator. That is, for each n such that 0 &lt;= n &lt; last - first, it performs the assignment *(result + n) = op(*(first + n)). The return value is result + (last - first). </p>

<p>References <a class="el" href="group__PredicateAlgorithms.html#ga6a4516cd4b2891c8267d0a02a99d6661">ustl::transform()</a>.</p>

</div>
</div>
<a class="anchor" id="gae2102561c0d380e16e1effabeba58754"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename InputIterator , typename OutputIterator , typename BinaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::transform </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunction&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The second version of transform is very similar, except that it uses a Binary Function instead of a Unary Function: it performs the operation op(*i1, *i2) for each iterator i1 in the range [first1, last1) and assigns the result to *o, where i2 is the corresponding iterator in the second input range and where o is the corresponding output iterator. That is, for each n such that 0 &lt;= n &lt; last1 - first1, it performs the assignment *(result + n) = op(*(first1 + n), *(first2 + n). The return value is result + (last1 - first1). </p>

<p>References <a class="el" href="group__PredicateAlgorithms.html#ga6a4516cd4b2891c8267d0a02a99d6661">ustl::transform()</a>.</p>

</div>
</div>
<a class="anchor" id="gad18dd0f3a49cf57f7b06b77df5a379e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::unique </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Every time a consecutive group of duplicate elements appears in the range [first, last), the algorithm unique removes all but the first element. That is, unique returns an iterator new_last such that the range [first, new_last) contains no two consecutive elements that are duplicates. The iterators in the range [new_last, last) are all still dereferenceable, but the elements that they point to are unspecified. Unique is stable, meaning that the relative order of elements that are not removed is unchanged. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gae843d0bdce4ccf55205edb33eb3ba0d0">ustl::unique_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga040d93fb7659f4a30075759df2db827e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::unique </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Every time a consecutive group of duplicate elements appears in the range [first, last), the algorithm unique removes all but the first element. That is, unique returns an iterator new_last such that the range [first, new_last) contains no two consecutive elements that are duplicates. The iterators in the range [new_last, last) are all still dereferenceable, but the elements that they point to are unspecified. Unique is stable, meaning that the relative order of elements that are not removed is unchanged. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gae843d0bdce4ccf55205edb33eb3ba0d0">ustl::unique_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga692dd0a978c4f31bacc653defaead8f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator ustl::unique </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Every time a consecutive group of duplicate elements appears in the range [first, last), the algorithm unique removes all but the first element. That is, unique returns an iterator new_last such that the range [first, new_last) contains no two consecutive elements that are duplicates. The iterators in the range [new_last, last) are all still dereferenceable, but the elements that they point to are unspecified. Unique is stable, meaning that the relative order of elements that are not removed is unchanged. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gae843d0bdce4ccf55205edb33eb3ba0d0">ustl::unique_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga013e60a5eb03c93781f9ade1c724beec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::unique_copy </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>ctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unique_copy copies elements from the range [first, last) to a range beginning with result, except that in a consecutive group of duplicate elements only the first one is copied. The return value is the end of the range to which the elements are copied. This behavior is similar to the Unix filter uniq. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gae843d0bdce4ccf55205edb33eb3ba0d0">ustl::unique_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="gae843d0bdce4ccf55205edb33eb3ba0d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::unique_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unique_copy copies elements from the range [first, last) to a range beginning with result, except that in a consecutive group of duplicate elements only the first one is copied. The return value is the end of the range to which the elements are copied. This behavior is similar to the Unix filter uniq. </p>

<p>Referenced by <a class="el" href="group__MutatingAlgorithms.html#ga692dd0a978c4f31bacc653defaead8f3">ustl::unique()</a>, and <a class="el" href="group__MutatingAlgorithms.html#ga013e60a5eb03c93781f9ade1c724beec">ustl::unique_copy()</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr>
<address style="align: right;">
<small>
    Generated on Tue Jan 21 2014 20:21:00 for uSTL by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.6
</small>
</address>
</body>
</html>
