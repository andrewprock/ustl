<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Functor Object Accessors</title>
    <link href="../style/default.css" rel="stylesheet" type="text/css" />
    <link href="../style/ustlstyle.css" rel="stylesheet" type="text/css" />
    <meta http-equiv="Content-Type" content="text/xhtml+xml; charset=ISO-8859-1" />
    <meta name="Description" content="API and usage description for uSTL, a size-optimized STL implementation" />
    <meta name="Keywords" content="C++, STL, template, bloat, optimization" />
</head>
<body>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functor Object Accessors<div class="ingroups"><a class="el" href="group__Functors.html">Functors</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga692b000017859bcaa7f5fc26171da68e"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Result &gt; </td></tr>
<tr class="memitem:ga692b000017859bcaa7f5fc26171da68e"><td class="memTemplItemLeft" align="right" valign="top">pointer_to_unary_function&lt; Arg, <br class="typebreak"/>
Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga692b000017859bcaa7f5fc26171da68e">ustl::ptr_fun</a> (Result(*pfn)(Arg))</td></tr>
<tr class="separator:ga692b000017859bcaa7f5fc26171da68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134fe8f77eeaaf8ec0cbe57c70763455"><td class="memTemplParams" colspan="2">template&lt;typename Arg1 , typename Arg2 , typename Result &gt; </td></tr>
<tr class="memitem:ga134fe8f77eeaaf8ec0cbe57c70763455"><td class="memTemplItemLeft" align="right" valign="top">pointer_to_binary_function<br class="typebreak"/>
&lt; Arg1, Arg2, Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga134fe8f77eeaaf8ec0cbe57c70763455">ustl::ptr_fun</a> (Result(*pfn)(Arg1, Arg2))</td></tr>
<tr class="separator:ga134fe8f77eeaaf8ec0cbe57c70763455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be1e0def5a92308f595105e8787a32a"><td class="memTemplParams" colspan="2">template&lt;class UnaryFunction &gt; </td></tr>
<tr class="memitem:ga1be1e0def5a92308f595105e8787a32a"><td class="memTemplItemLeft" align="right" valign="top">unary_negate&lt; UnaryFunction &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga1be1e0def5a92308f595105e8787a32a">ustl::unary_negator</a> (UnaryFunction pfn)</td></tr>
<tr class="separator:ga1be1e0def5a92308f595105e8787a32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17eadb603a5cd87eefde8b362440c061"><td class="memTemplParams" colspan="2">template&lt;typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga17eadb603a5cd87eefde8b362440c061"><td class="memTemplItemLeft" align="right" valign="top">binder1st&lt; BinaryFunction &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga17eadb603a5cd87eefde8b362440c061">ustl::bind1st</a> (BinaryFunction pfn, typename BinaryFunction::first_argument_type v)</td></tr>
<tr class="separator:ga17eadb603a5cd87eefde8b362440c061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e4e019298b2082e148d74eb73948692"><td class="memTemplParams" colspan="2">template&lt;typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga6e4e019298b2082e148d74eb73948692"><td class="memTemplItemLeft" align="right" valign="top">binder2nd&lt; BinaryFunction &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga6e4e019298b2082e148d74eb73948692">ustl::bind2nd</a> (BinaryFunction pfn, typename BinaryFunction::second_argument_type v)</td></tr>
<tr class="separator:ga6e4e019298b2082e148d74eb73948692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78abf2b817501b4f18ffde6809ad7d0c"><td class="memTemplParams" colspan="2">template&lt;typename Operation1 , typename Operation2 &gt; </td></tr>
<tr class="memitem:ga78abf2b817501b4f18ffde6809ad7d0c"><td class="memTemplItemLeft" align="right" valign="top">unary_compose&lt; Operation1, <br class="typebreak"/>
Operation2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga78abf2b817501b4f18ffde6809ad7d0c">ustl::compose1</a> (const Operation1 &amp;f, const Operation2 &amp;g)</td></tr>
<tr class="separator:ga78abf2b817501b4f18ffde6809ad7d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9fe0b2716cc7faf07098f19db7a7858"><td class="memTemplParams" colspan="2">template&lt;typename Operation1 , typename Operation2 , typename Operation3 &gt; </td></tr>
<tr class="memitem:gac9fe0b2716cc7faf07098f19db7a7858"><td class="memTemplItemLeft" align="right" valign="top">binary_compose&lt; Operation1, <br class="typebreak"/>
Operation2, Operation3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#gac9fe0b2716cc7faf07098f19db7a7858">ustl::compose2</a> (const Operation1 &amp;f, const Operation2 &amp;g, const Operation3 &amp;h)</td></tr>
<tr class="separator:gac9fe0b2716cc7faf07098f19db7a7858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b12abc35eccb51beb510fbd3d621142"><td class="memTemplParams" colspan="2">template&lt;class T , typename VT &gt; </td></tr>
<tr class="memitem:ga7b12abc35eccb51beb510fbd3d621142"><td class="memTemplItemLeft" align="right" valign="top">const_mem_var1_t&lt; binder2nd<br class="typebreak"/>
&lt; equal_to&lt; VT &gt; &gt;, T, VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga7b12abc35eccb51beb510fbd3d621142">ustl::mem_var_equal_to</a> (const VT T::*mvp, const VT &amp;v)</td></tr>
<tr class="separator:ga7b12abc35eccb51beb510fbd3d621142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7778bd67b0068ced3e711aae65adc417"><td class="memTemplParams" colspan="2">template&lt;class T , typename VT &gt; </td></tr>
<tr class="memitem:ga7778bd67b0068ced3e711aae65adc417"><td class="memTemplItemLeft" align="right" valign="top">const_mem_var1_t&lt; binder2nd<br class="typebreak"/>
&lt; less&lt; VT &gt; &gt;, T, VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga7778bd67b0068ced3e711aae65adc417">ustl::mem_var_less</a> (const VT T::*mvp, const VT &amp;v)</td></tr>
<tr class="separator:ga7778bd67b0068ced3e711aae65adc417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82a5be23fb831c5a77c7d453b8c85a4"><td class="memTemplParams" colspan="2">template&lt;class T , typename VT &gt; </td></tr>
<tr class="memitem:gad82a5be23fb831c5a77c7d453b8c85a4"><td class="memTemplItemLeft" align="right" valign="top">const_mem_var2_t&lt; equal_to&lt; VT &gt;<br class="typebreak"/>
, T, VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#gad82a5be23fb831c5a77c7d453b8c85a4">ustl::mem_var_equal_to</a> (const VT T::*mvp)</td></tr>
<tr class="separator:gad82a5be23fb831c5a77c7d453b8c85a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe924449ab4bd470bfb963563fe108ba"><td class="memTemplParams" colspan="2">template&lt;class T , typename VT &gt; </td></tr>
<tr class="memitem:gafe924449ab4bd470bfb963563fe108ba"><td class="memTemplItemLeft" align="right" valign="top">const_mem_var2_t&lt; less&lt; VT &gt;<br class="typebreak"/>
, T, VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#gafe924449ab4bd470bfb963563fe108ba">ustl::mem_var_less</a> (const VT T::*mvp)</td></tr>
<tr class="separator:gafe924449ab4bd470bfb963563fe108ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Because C++ is so very unsuited to functional programming, trying to do so may require a lot of typing. These accessor functions are somewhat helpful in making functional constructs more readable. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga17eadb603a5cd87eefde8b362440c061"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BinaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">binder1st&lt;BinaryFunction&gt; ustl::bind1st </td>
          <td>(</td>
          <td class="paramtype">BinaryFunction&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename BinaryFunction::first_argument_type&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts <code>pfn</code> into a unary function by binding the first argument to <code>v</code>. </p>

</div>
</div>
<a class="anchor" id="ga6e4e019298b2082e148d74eb73948692"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BinaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">binder2nd&lt;BinaryFunction&gt; ustl::bind2nd </td>
          <td>(</td>
          <td class="paramtype">BinaryFunction&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename BinaryFunction::second_argument_type&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts <code>pfn</code> into a unary function by binding the second argument to <code>v</code>. </p>

<p>Referenced by <a class="el" href="group__FunctorAccessors.html#ga7b12abc35eccb51beb510fbd3d621142">ustl::mem_var_equal_to()</a>, and <a class="el" href="group__FunctorAccessors.html#ga7778bd67b0068ced3e711aae65adc417">ustl::mem_var_less()</a>.</p>

</div>
</div>
<a class="anchor" id="ga78abf2b817501b4f18ffde6809ad7d0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Operation1 , typename Operation2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unary_compose&lt;Operation1, Operation2&gt; ustl::compose1 </td>
          <td>(</td>
          <td class="paramtype">const Operation1 &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Operation2 &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classustl_1_1unary__compose.html">unary_compose</a> object whose function c(x)=f(g(x)) </p>

</div>
</div>
<a class="anchor" id="gac9fe0b2716cc7faf07098f19db7a7858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Operation1 , typename Operation2 , typename Operation3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">binary_compose&lt;Operation1, Operation2, Operation3&gt; ustl::compose2 </td>
          <td>(</td>
          <td class="paramtype">const Operation1 &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Operation2 &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Operation3 &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classustl_1_1binary__compose.html">binary_compose</a> object whose function c(x)=f(g(x),h(x)) </p>

</div>
</div>
<a class="anchor" id="ga7b12abc35eccb51beb510fbd3d621142"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_mem_var1_t&lt;binder2nd&lt;equal_to&lt;VT&gt; &gt;, T, VT&gt; ustl::mem_var_equal_to </td>
          <td>(</td>
          <td class="paramtype">const VT T::*&#160;</td>
          <td class="paramname"><em>mvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returned functor passes member variable <code>mvp</code> reference of given object to equal&lt;VT&gt;. </p>

<p>References <a class="el" href="group__FunctorAccessors.html#ga6e4e019298b2082e148d74eb73948692">ustl::bind2nd()</a>.</p>

</div>
</div>
<a class="anchor" id="gad82a5be23fb831c5a77c7d453b8c85a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_mem_var2_t&lt;equal_to&lt;VT&gt;, T, VT&gt; ustl::mem_var_equal_to </td>
          <td>(</td>
          <td class="paramtype">const VT T::*&#160;</td>
          <td class="paramname"><em>mvp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returned functor passes member variable <code>mvp</code> reference of given object to equal&lt;VT&gt;. </p>

</div>
</div>
<a class="anchor" id="ga7778bd67b0068ced3e711aae65adc417"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_mem_var1_t&lt;binder2nd&lt;less&lt;VT&gt; &gt;, T, VT&gt; ustl::mem_var_less </td>
          <td>(</td>
          <td class="paramtype">const VT T::*&#160;</td>
          <td class="paramname"><em>mvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returned functor passes member variable <code>mvp</code> reference of given object to less&lt;VT&gt;. </p>

<p>References <a class="el" href="group__FunctorAccessors.html#ga6e4e019298b2082e148d74eb73948692">ustl::bind2nd()</a>.</p>

</div>
</div>
<a class="anchor" id="gafe924449ab4bd470bfb963563fe108ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_mem_var2_t&lt;less&lt;VT&gt;, T, VT&gt; ustl::mem_var_less </td>
          <td>(</td>
          <td class="paramtype">const VT T::*&#160;</td>
          <td class="paramname"><em>mvp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returned functor passes member variable <code>mvp</code> reference of given object to less&lt;VT&gt;. </p>

</div>
</div>
<a class="anchor" id="ga692b000017859bcaa7f5fc26171da68e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pointer_to_unary_function&lt;Arg,Result&gt; ustl::ptr_fun </td>
          <td>(</td>
          <td class="paramtype">Result(*)(Arg)&#160;</td>
          <td class="paramname"><em>pfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ptr_fun(pfn) wraps function pointer pfn into a functor class that calls it. </p>

</div>
</div>
<a class="anchor" id="ga134fe8f77eeaaf8ec0cbe57c70763455"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg1 , typename Arg2 , typename Result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pointer_to_binary_function&lt;Arg1,Arg2,Result&gt; ustl::ptr_fun </td>
          <td>(</td>
          <td class="paramtype">Result(*)(Arg1, Arg2)&#160;</td>
          <td class="paramname"><em>pfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ptr_fun(pfn) wraps function pointer pfn into a functor class that calls it. </p>

</div>
</div>
<a class="anchor" id="ga1be1e0def5a92308f595105e8787a32a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unary_negate&lt;UnaryFunction&gt; ustl::unary_negator </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>pfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the functor that negates the result of *pfn(). </p>

</div>
</div>
</div><!-- contents -->
<hr>
<address style="align: right;">
<small>
    Generated on Tue Jan 21 2014 20:21:00 for uSTL by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.6
</small>
</address>
</body>
</html>
