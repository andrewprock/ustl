<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Main Page</title>
    <link href="../style/default.css" rel="stylesheet" type="text/css" />
    <link href="../style/ustlstyle.css" rel="stylesheet" type="text/css" />
    <meta http-equiv="Content-Type" content="text/xhtml+xml; charset=ISO-8859-1" />
    <meta name="Description" content="API and usage description for uSTL, a size-optimized STL implementation" />
    <meta name="Keywords" content="C++, STL, template, bloat, optimization" />
</head>
<body>
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">uSTL Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>uSTL is a partial implementation of the STL specification intended to reduce code size of the derivative programs. Usually, the STL containers manage their own storage with new[] and delete[] operators, which create strongly typed storage. That is the standard way of allocating C++ object vectors, allowing appropriate constructors and destructors to be called on the allocated storage and ensuring that objects are copied via their copy operators. Although type safety is a good thing, placing memory management code into a template necessitates its reinstantiation for every template instance used by the derivative program. This produces substantial code bloat, that is frequently derided by C developers and used by them as an argument that C is better than C++. The uSTL implementation solves this problem by factoring memory management code into a non-template base class, <a class="el" href="classustl_1_1memblock.html" title="Allocated memory block. ">ustl::memblock</a>, which performs unstructured memory allocation. STL containers are then implemented as template wrappers for memblock to provide a measure of type safety. The result is that each template instantiation contains less code, and although it does not completely "disappear", due to the requirement for calling placement constructors on the allocated memory, most of it does, being replaced by calls to memblock methods. The base classes for unstructured storage management (cmemlink - link to constant memory, memlink - link to mutable memory, and memblock - owner of mutable memory) are, of course, also available for use as data buffers wherever those are needed, and streams that efficiently read and write binary data into them are also available. </p>
</div></div><!-- contents -->
<hr>
<address style="align: right;">
<small>
    Generated on Sat Nov 9 2013 13:57:32 for uSTL by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.5
</small>
</address>
</body>
</html>
